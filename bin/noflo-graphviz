#!/usr/bin/env coffee
# vim: set filetype=coffee:
path = require 'path'
noflo = require 'noflo'
graphviz = require 'graphviz'

if process.argv.length < 3
  console.log "Usage: $ graphviz-noflo file.fbp"
  process.exit 0

file = path.resolve process.cwd(), process.argv[2]
if file.indexOf('.json') is -1 and file.indexOf('.fbp') is -1
  console.error "#{file} is not a NoFlo graph file, aborting"
  process.exit 0

cleanID = (id) ->
  id.replace /\s*/g, ""
cleanPort = (port) ->
  port = port.toUpperCase()
  port.replace /\./g, ""

getShape = (component, instance) ->
  switch component
    when 'Kick' then return 'hexagon'
    when 'SendString' then return 'hexagon'
    else return 'box'

colors =
  component:
    fill: '#204a87'
    label: '#ffffff'
  graph:
    fill: '#5c3566'
    label: '#ffffff'
  gate:
    fill: '#a40000'
    label: '#ffffff'
  initial:
    edge: '#2e3436'
    fill: '#eeeeec'
    label: '#555753'
  port:
    label: '#555753'
  export:
    fill: '#e9b96e'
    label: '#000000'

basedir = path.resolve path.dirname(file), '..'
loader = new noflo.ComponentLoader basedir
nodes = {}
noflo.graph.loadFile file, (graph) ->
  g = graphviz.digraph path.basename file, path.extname file
  loader.listComponents (components) ->
    renderNodes graph, g, ->
      renderInitials graph, g
      renderExports graph, g
      renderEdges graph, g
      render g

renderNodes = (graph, g, done) ->
  todo = graph.nodes.length
  do done if todo is 0
  graph.nodes.forEach (node) ->
    component = loader.load node.component, (instance) ->
      params =
        label: "#{node.id}\n#{node.component}"
        shape: getShape node.component, instance
        style: 'filled,rounded'
        fillcolor: colors.component.fill
        fontcolor: colors.component.label
      if instance.isSubgraph()
        params.fillcolor = colors.graph.fill
        params.fontcolor = colors.graph.label
      if params.shape is 'hexagon'
        params.fillcolor = colors.gate.fill
        params.fontcolor = colors.gate.label

      nodes[node.id] = g.addNode cleanID(node.id), params
      instance = null
      todo--
      do done if todo is 0

renderInitials = (graph, g) ->
  for initializer, id in graph.initializers
    identifier = "data#{id}"
    nodes[identifier] = g.addNode identifier,
      label: "'#{initializer.from.data}'"
      shape: 'plaintext'
      style: 'filled,rounded'
      fontcolor: colors.initial.label
      fillcolor: colors.initial.fill
    g.addEdge nodes[identifier], nodes[initializer.to.node],
      headlabel: cleanPort initializer.to.port
      labelfontcolor: colors.port.label
      labelfontsize: 0.8
      color: colors.initial.edge

renderExports = (graph, g) ->
  for exported in graph.exports
    identifier = "export#{exported.public}"
    [nodeId, port] = exported.private.split '.'
    switch port
      when 'error', 'errors', 'out'
        direction = 'from'
      else
        direction = 'to'

    nodes[identifier] = g.addNode identifier,
      label: exported.public.toUpperCase()
      shape: if direction is 'to' then 'circle' else 'doublecircle'
      fontcolor: colors.export.label
      fillcolor: colors.export.fill
      style: 'filled'

    for node in graph.nodes
      continue unless node.id.toLowerCase() is nodeId
      if direction is 'to'
        g.addEdge nodes[identifier], nodes[cleanID(node.id)],
          headlabel: cleanPort port
          labelfontcolor: colors.port.label
          labelfontsize: 8.0
        continue
      g.addEdge nodes[cleanID(node.id)], nodes[identifier],
        headlabel: cleanPort port
        labelfontcolor: colors.port.label
        labelfontsize: 8.0

renderEdges = (graph, g) ->
  for edge in graph.edges
    continue unless nodes[edge.from.node] and nodes[edge.to.node]
    g.addEdge nodes[edge.from.node], nodes[edge.to.node],
      taillabel: cleanPort edge.from.port
      headlabel: cleanPort edge.to.port
      labelfontcolor: colors.port.label
      labelfontsize: 8.0

render = (g) ->
  g.render
    type: 'svg'
    use: 'dot'
  , "#{g.id}.svg"
  process.nextTick ->
    setTimeout ->
      process.exit 0
    , 3000
